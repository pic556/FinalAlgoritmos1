Ejercicio 1.  Las siguientes especificaciones no son correctas. Indicar por que, y corregirlas para que describan correctamente
el problema.
a) buscar: Dada una secuencia y un elemento de esta, devuelve en result alguna posicion de la secuencia en la cual se encuentre
el elemento.
proc buscar (in l: seq<R>, in elem: R, out result: Z) {
Pre {elem ∈ l}
Post {0 ≤ result < |l| ∧L	
	l[result] = elem}
}
b) progresionGeometricaFactor2: Indica si la secuencia l representa una progresion geometrica factor 2. Es decir, si cada
elemento de la secuencia es el doble del elemento anterior.
proc progresionGeometricaFactor2 (in l: seqhZi, out result: Bool) {
Pre {T rue}
Post {result = True ↔ ((∀i : Z)(0 ≤ i < |l|-1 →L l[i] = 2 ∗ l[i + 1]))}
}
c) minimo: Devuelve en result el menor elemento de l.
proc minimo (in l: seqhZi, out result: Z) {
Pre {True}
Post {(∀i : Z)(0 ≤i <|l|) →L (∃ result)(0 ≤ result <|l| l[i] => result))}
}

Ejercicio 2. La siguiente no es una especificacion valida, ya que para ciertos valores de entrada que cumplen la precondicion,
no existe una salida que cumpla con la postcondicion.
proc elementosQueSumen (in l: seq<Z>, in suma:Z, out result: seq<Z>) {
Pre {True}
Post {
/* La secuencia result esta incluıda en la secuencia l*/
(∀x : Z)(x ∈ result → #apariciones(x, result) ≤ #apariciones(x, l))
/* La suma de la result coincide con el valor suma */
∧ suma=sum(|result|−1,0,i) result[i]}
}
a) Mostrar valores para l y suma que hagan verdadera la precondicion, pero tales que no exista result que cumpla la postcondicion.

l=[1,2,3]
suma=3
result[1,2]

l=[]
suma=1
suma de result = 0 

b) Supongamos que agregamos a la especificacion la siguiente clausula:
Pre : min suma(l) ≤ suma ≤ max suma(l)
fun min suma(l) : Z =
|l|−1
i=0 if l[i] < 0 then l[i] else 0 fi
fun max suma(l) : Z =
|l|−1
i=0 if l[i] > 0 then l[i] else 0 fi
¿Ahora es una especificacion valida? Si no lo es, justificarlo con un ejemplo como en el punto anterior 

se rompen con 
l=[1,3]
suma=2

c) Dar una precondici´on que haga correcta la especificaci´on.
|l| ≥ 1 ∧l suma ≤ maximo(l)



Ejercicio 3. Para los siguientes problemas, dar todas las soluciones posibles a las entradas dadas.
a) proc raizCuadrada (in x:R, out result:R) {
Pre {x ≥ 0}
Post {result^2  = x}
}
i) x = 0 ⇒ 0
ii) x = 1 ⇒ 1 and -1
iii) x = 27 ⇒ sqrt(27) , -sqrt(27)


proc indiceDelMaximo (in l: seqhRi, out result:Z) {
Pre {|l| > 0}
Post {
0 ≤ result < |l|
∧L ((∀i : Z)(0 ≤ i < |l| →L l[i] ≤ l[result])}
}

i) l = h1, 2, 3, 4i   ⇒  3
ii) l = h15.5, −18, 4.215, 15.5, −1i ⇒ 0 ,3
iii) l = h0, 0, 0, 0, 0, 0i ⇒ 0,1..5 

c) 
proc indiceDelPrimerMaximo (l:seqhRi, result:Z) {
Pre {|l| > 0}
Post {
0 ≤ result < |l|
∧ ((∀i : Z)(0 ≤ i < |l| →L (l[i] < l[result] ∨ (l[i] = l[result] ∧ i ≥ result))))}
}
i) l = h1, 2, 3, 4i ⇒ 3
ii) l = h15.5, −18, 4.215, 15.5, −1i ⇒0
iii) l = h0, 0, 0, 0, 0, 0i ⇒0


Ejercicio 4. F Sea f : R × R → R definida como:
				
					| 2b si a < 0
f(a, b) = | b − 1 en otro caso

¿Cuales de las siguientes especificaciones son correctas para el problema de calcular f(x, y)?
Para las que no lo son, indicar por que

a) proc f (in a, b:R ,out result:R) {
Pre {True}
Post {
(a < 0 ∧ result = 2 ∗ b)
∧
(a ≥ 0 ∧ result = b − 1)
}
}
sera falso ,debe haber un ∨ no un ∧

b) proc f (in a, b: R, out result:R) {
Pre {True}
Post {(a < 0 ∧ result = 2 ∗ b) ∨ (a > 0 ∧ result = b − 1)}
}
incorrecto

c) proc f (in a, b: R, out result:R) {
Pre {T rue}
Post {(a < 0 ∧ result = 2 ∗ b) ∨ (a ≥ 0 ∧ result = b − 1)}
}
correcto 

d) proc f (in a, b: R, out result:R) {
Pre {T rue}
Post {
a < 0 → result = 2 ∗ b
∧
a ≥ 0 → result = b − 1
}
}
incorrecto

e) proc f (in a, b: R, out result:R) {
Pre {T rue}
Post {(a < 0 → result = 2 ∗ b) ∨ (a ≥ 0 → result = b − 1)}
}
incorrecto

f) proc f (in a, b: R, out result: R) {
Pre {T rue}
Post {result = (if a < 0 then 2 ∗ b else b − 1 fi)}
}
correcto 


Ejercicio 5. Considerar la siguiente especificacion, junto con un algoritmo que dado x devuelve x^2

proc unoMasGrande (in x: R, out result:R) {
Pre {T rue}
Post {result > x}
}
a) ¿Que devuelve el algoritmo si recibe x = 3? ¿El resultado hace verdadera la postcondicion de unoMasGrande?
devuelve 9 y hace verdadera
b) ¿Que sucede para las entradas x = 0.5, x = 1, x = −0.2 y x = −7?
da 0.25 pero no cumple postcondicion, 1 da 1 no cumple posticoindcion ,da 49 y cumple postcondicon
c) Teniendo en cuenta lo respondido en los puntos anteriores, escribir una precondicion para unoMasGrande, de manera tal que
el algoritmo sea una implementacion correcta.
pre{x>1 ∨ x≤-1 }


Ejercicio 6.  Sean x y r variables de tipo R. Considerar los siguientes predicados:

P1: {x ≤ 0} 		Q1: {r ≥ x^2}
P2: {x ≤ 10} 		Q2: {r ≥ 0}
P3: {x ≤ −10}   Q3: {r = x^2}

a) Indicar la relaci´on de fuerza entre P1, P2 y P3.
P3 > P1 > P2
b) Indicar la relaci´on de fuerza enrte Q1, Q2 y Q3.
Q3 > Q1 > Q2

c) Sea E1 la siguiente especificaci´on. Escribir 2 programas que cumplan con E1.
proc hagoAlgo (in x: R, out r:R) {
Pre {x ≤ 0}
Post {r ≥ x^2}
}

f(x:R){
	result = x * x 
	return result 
}
r : = (x − 1)^2 , r := x^2

d) Sea A un algoritmo que cumple con E1. Decidir si necesariamente cumple las siguientes especificaciones:
a) Pre: {x ≤ −10}, Post: {r ≥ x^2}si
b) Pre: {x ≤ 10}, Post: {r ≥ x^2}no
c) Pre: {x ≤ 0}, Post: {r ≥ 0}si
d) Pre: {x ≤ 0}, Post: {r = x^2}no
e) Pre: {x ≤ −10}, Post: {r ≥ 0}si
f ) Pre: {x ≤ 10}, Post: {r ≥ 0}no
g) Pre: {x ≤ −10}, Post: {r = x^2}no
h) Pre: {x ≤ 10}, Post: {r = x^2}no


Ejercicio 7.  Considerar las siguientes dos especificaciones, junto con un algoritmo a que satisface la especificacion de p2.

proc p1 (in x: R, in n: Z, out result:Z) {
Pre {x ≠ 0}
Post {x^(n)− 1 < result ≤ x^n}
}
proc p2 (in x: R, in n: Z, out result:Z) {
Pre {n ≤ 0 → x ≠ 0}
Post {result = parteEntera(x^n)}
}

a) Dados valores de x y n que hacen verdadera la precondicion de p1, demostrar que hacen tambien verdadera la precondicion
de p2.
si x ≠ 0 entonces en el pre de p2 el n tiene que se menor a 0 y no hay restricion asi que esta bien 
b) Ahora, dados estos valores de x y n, supongamos que se ejecuta a: llegamos a un valor de res que hace verdadera la
postcondicion de p2. ¿Sera tambien verdadera la postcondicion de p1?
cumple
c) ¿Podemos concluir que a satisface la especificacion de p1?
si x=2 y n=-1 
1/2 result 1/2 falso 

Ejercicio 8. Considerar las siguientes especificaciones:
proc n-esimo1 (in l: seqhZi, in n: Z, out result: Z) {
Pre {
/*Los elementos estan ordenados*/
(∀i : Z)(0 ≤ i < |l| − 1 →L l[i] < l[i + 1]) ∧ 0 ≤ n < |l|}
Post {result = l[n]}
}


proc n-esimo2 (in l: seqhZi, in n: Z, out result:Z) {
Pre {
/*Los elementos son distintos entre sı*/
(∀i : Z)(0 ≤ i < |l| →L ((∀j : Z)(0 ≤ j < |l| ∧ i != j) →L l[i] != l[j]))
∧
0 ≤ n < |l|}
Post {
result ∈ l
∧
n =sum(l,0,|l|-1,i)(if l[i] < result then 1 else 0 fi)}
}
¿Es cierto que todo algoritmo que cumple con n-esimo1 cumple tambi´en con n-esimo2? ¿Y al rev´es?
Si un algoritmo cumple la pre de p1, entonces cumple la de p2. Ya que una lista ordenada
tiene todos elementos distintos, y ambos aseguran que 0 ≤ n < |l|. Pero si cumple la pre de
p2 no necesariamente cumple la de p1 (ej.: h1, 3, 2i).
Y la post de p1 tambi´en cumple p2. Porque la sumatoria de p2 est´a preguntando cu´antos
n´umeros menores a result hay, que es lo mismo que la posici´on de la secuencia ordenada

Ejercicio 9. F Especificar los siguientes problemas:
a) Dado un numero entero, decidir si es par.
proc esPar (in n: Z, out res: Bool) {
Pre {T rue}
Post {eje_a(n)}
}
pred eje_a(x:Z){
	x mod 2 == 0
}
b) Dado un entero n y uno m, decidir si n es un multiplo de m.
proc esMultiplo (in n, m: Z, out res: Bool) {
Pre {T rue}
Post {eje_b(n,m)}
}
pred eje_b(n,m:Z){
	n mod m == 0
}
c) Dado un numero real, devolver su inverso multiplicativo.
c) proc inverso (in x: R, out res: R) {
Pre {x != 0}
Post {res = inv_mul(x) }
}
aux inv_mul(x:R):R = (if x==0 then 0 else 1/x)
d) Dada una secuencia de caracteres, obtener de ella solo los que son numericos (con todas sus apariciones sin importar el orden
de aparicion).
d) proc obtenerNumericos ( in l : seqhChari, out lis : seqhChari) {
Pre {T rue}
Post {(∀c : Char) ( (ord(‘0‘) ≤ ord(c) ≤ ord(‘9‘) → apariciones(c, l) ==
apariciones(c, lis)) ∧ (c ∈ lis → ord(‘0‘) ≤ ord(c) ≤ ord(‘9‘) ))}
}
e) Dada una secuencia de reales, devolver la secuencia que resulta de duplicar sus valores en las posiciones impares
proc dupl_imp(in s: seq<R> ,out res:seq<R>){
	pre{True}
	post{ |s|=|res| ∧L
	(∀i:z)(0 ≤ i < |s| ⇒L  
		if i mod 2 == 0 then s[i]=res[i] else res[i]=s[i]*2
		}
}
f) Dado un numero entero, listar todos sus divisores positivos (sin duplicados).
proc divisoresPositivos (in n: Z, out res: seqhZi) {
Pre {T rue}
Post {sinRepetidos(res) ∧ (∀i : Z)((i > 0 ∧L n m´od i == 0) ↔ i ∈ res)}
}


Ejercicio 10. Considerar el problema de decidir, dados n y m enteros, si n es m´ultiplo de m, y la siguiente especificaci´on.
proc esMultiplo (in n, m: Z, out result:Bool) {
Pre {m != 0}
Post {result = (n mod m == 0)}
}
a) Segun la definicion matematica de multiplo, ¿tiene sentido preguntarse si 4 es multiplo de 0? ¿Cual es la respuesta?
no tiene
b) ¿Deberıa ser n = 4, m = 0 una entrada valida para el problema? ¿Lo es en esta especificacion?
el problema deberia dar false ,la especificacion aca ni entra

c) Corregir la especificacion de manera tal que n = 4, m = 0 satisfaga la precondicion (¡cuidado con las indefiniciones!).
res==n*k=m
d) ¿Que relacion de fuerza hay entre la precondicion nueva y la original?
la original es mas fuerte debido a que si se cancela esta daria verdadero ,en cambio una da verdadero siempre pero la otra no 


Ejercicio 11. Considerar el problema de, dada una secuencia de n´umeros reales, devolver la que resulta de duplicar sus valores
en las posiciones impares.
a) Para la secuencia h1, 2, 3, 4i, ¿es h0, 4, 0, 8i un resultado correcto?NO 
b) Sea la siguiente especificaci´on:
proc duplicarEnImpares (in l: seqhRi, out result: seqhRi) {
Pre {T rue}
Post {|result| = |l| ∧L (∀i : Z)((0 ≤ i < |result| ∧ i m´od 2 == 1) →L result[i] == l[i]*2)}
}
d) ¿Qu´e relaci´on de fuerza hay entre la nueva postcondici´on y la original?NINGUNA 


Ejercicio 12. F Especificar el problema de dado un entero positivo retornar una secuencia de 0s y 1s que represente ese n´umero
en base 2 (es decir, en binario).
pred solo0Y1 (res: seqhZi) {
(∀i : Z)(0 ≤ i < |res| −→L res[i] == 0 ∨ res[i] = 1)
}

aux binADec (res: seqhZi) : Z =
P|res|−1
i=0 2
|res|−1−i
· res[i] ;

proc esBinario (in n: Z, out res: seqhZi) {
Pre {0 ≤ n}
Post {solo0Y 1(res) ∧ n == binADec(res)}
}



Ejercicio 13. Con lo visto en los ejercicios 9 a 12, ¿Encuentra casos de sub y sobreespecificaci´on en las especificaciones del
ejercicio 8?
sobreespcificado la pre y sub la post


Ejercicio 14. Especificar los siguientes problemas:
a) F Dado un numero entero positivo, obtener la suma de sus factores primos.
suma_factores_primos(in x:Z , result:R){
	pre{ x≥1}
	post{res = sum(1,x,i) if esprimo(i) and x mod i == 0 then i else 0 fi}
}
b) Dado un numero entero positivo, decidir si es perfecto. Se dice que un numero es perfecto cuando es igual a la suma de sus
divisores (excluyendose a sı mismo).
perfecto(in x:Z , out result:bool){
	pre{ x≥1}
	post{x = sum(1,x,i) if x mod i == 0 then i else 0 fi}
}
c) Dado un numero entero positivo n, obtener el menor entero positivo m > 1 tal que m sea coprimo con n.
perfecto(in n:Z , out m:Z){
	pre{ n>0}
	post{ {m > 1∧sonCoprimos(n, m)∧L(∄m : Z)(2 ≤ m < res ∧sonCoprimos(n, m)) }
}
d) F Dado un entero positivo, obtener su descomposicion en factores primos. Devolver una secuencia de tuplas (p, e), donde p
es un factor primo y e es su exponente, ordenada en forma creciente con respecto a p.
suma_factores_primos(in x:Z , res:seq(ZxZ){
	pre{ x≥1}
	post{(∀i:Z)(0 ≤ i < x ∧ esprimo(i) ∧ x mod i  == 0 ⇒L 
		(∃e:Z)( x mod i ^ e == 0 ∧ <i,e> ∈ res  }
}
e) Dada una secuencia de numeros reales, obtener la diferencia maxima entre dos de sus elementos.
secuenc_dif_max(in s:seq<Z> , out res:Z){
	pre{ |s|>0}
	post{res = maximoValoren(s)-minimoValoren(s)}
}
f) F Dada una secuencia de numeros enteros, devolver aquel que divida a mas elementos de dicha secuencia. El elemento tiene
que pertenecer a la secuencia original. Si existe mas de un elemento que cumple esta propiedad, devolver alguno de ellos.
ele_que_mas_divida(in s:seq<Z> ,out res:Z){
	pre{|s|>0}
	post{(∃i:Z)((0 ≤ i < |s| ∧ esELquemasDivide(s[i],s) ⇒L res = s[i]))}
}
pred esELquemasDivide(n:Z , s: seq<Z>){
	(∄j:Z)(0 ≤ j < |s| ∧L cantidad_divide(s[j],s)>cantidad_divide(n,s) )
}

aux cantidad_divide(x:Z , s :seq<Z>)= sum(0,|s|-1,i) if s[i] mod x == 0 then 1 else 0 fi;

Ejercicio 15. Especificar los siguientes problemas sobre secuencias:
a) proc nEsimaAparicion(in l : seqhRi, in e : R, in n : Z, out result : Z), que devuelve el ındice de la n-esima aparicion de e en l.
proc nEsimaAparicion(in l : seqhRi, in e : R, in n : Z, out result : Z){
	Pre {0 < n ≤ apariciones(e, l)}
	Post {0 ≤ res < |l| ∧L (l[res] == e ∧ apariciones(e, subseq(l, 0, res)) == n − 1)}
}
b) Dadas dos secuencias s y t, decidir si s es una subcadena de t.
proc subcadena (in s,t:seq<T> ,out res:BOOL){
	pre{|s|<=|t|}
	post{(∃e,j:Z)(0<=e,j<=|t| ∧L res=(subseq(t,j,e)==s))}
}
c) F Dadas dos secuencias s y t, decidir si s esta incluida en t, es decir, si todos los elementos de s aparecen en t en igual o
mayor cantidad.
proc incluida(in s,t:seq<T> , out res:BOOL){
	pre{|s|<=|t|}
	post{(∀i:Z)(0<=i<|s| ⇒L res=(#apariciones(s[i],t)≥#apariciones(s[i],s))}
}
d) proc mezclarOrdenado(in s, t : seqhZi, out result : seqhZi), que recibe dos secuencias ordenadas y devuelve el resultado de
intercalar sus elementos de manera ordenada.
pre{true}
post{result=ordenar(concat(s,t)) }

e) Dadas dos secuencias s y t especificar el procedimiento interseccionSinRepetidos que retorna una secuencia que contiene
unicamente los elementos que aparecen en ambas secuencias.
proc interseccion_sin_repetidos(in s, t : seqhZi, out result : seqhZi){
	proc interseccionSinRepetidos ( in s,t : seqhZi, out res : seqhZi) {
	Pre {T rue}
	Post {sinRepetidos(res) ∧ (∀e : Z)((e ∈ s ∧ e ∈ t) ↔ e ∈ res)}
	}
f) F Dadas dos secuencias s y t, devolver su interseccion, es decir, una secuencia con todos los elementos que aparecen en
ambas. Si un mismo elemento tiene repetidos, la secuencia retornada debe contener la cantidad mınima de apariciones en de
s y de t.
proc interseccion (in s, t: seqhTi, out res: seqhTi) {
Pre {T rue}
Post {(∀ele : T)(min( apariciones(ele, s), apariciones(ele, t)) == apariciones(ele, inter))}
}

Ejercicio 16. Especificar los siguientes problemas:
a) proc cantApariciones(in l : String, out result : seqhChar × Zi) que devuelve la secuencia con todos los elementos de l, sin
duplicados, con su cantidad de apariciones(en un orden cualquiera). Ejemplos:
proc cantApariciones(in l : String, out result : seqhChar × Zi){
	pre{true}
	post{(∀i:Z)(0 ≤ i < |result|
		⇒L (∃j:ℤ)(0 ≤ j < |l| ∧L (result[i]_0 == l[j]  ∧ result[i]_1 == cantidad(l[j],j)  ∧ sinDuplicados(res)                
		)
		)}
}
pred sinDuplicados (res: seqhChar × Zi) {
(∀t : Char × Z)(t ∈ res −→ cantidadEnT uplas(t0, res) == 1)
}
aux cantidadEnTuplas (t: Char, res: seqhChar × Zi) : Z =
P|res|−1
i=0 if res[i]0 == t then 1 else 0 fi ;
b) Dada una secuencia, devolver una secuencia de secuencias que contenga todos sus prefijos, en orden creciente de longitud
aux secuenciadesecuencias(s:seq<T>):seqh seqhZi = 
(∀:iZ)(0 ≤ i < s ⇒L subseq(0,i,s) ++ subseq(0,i+1,s))
c) F Dada una secuencia de secuencias de enteros l, devolver una secuencia de l que contenga el m´aximo valor. Por ejemplo, si
proc secuencia_max_val (in s:seq<seqhZi> , out res:seq<Z>)) {
Pre {T rue}
Post {(∃i:Z)(0 ≤ i < |s| ∧ (secuenciaconmaximovalor(s[i],s)) ∧L res=s[i])}
}

pred secuenciaconmaximovalor(m:seq<Z>,s:seq<seqhZi>){
	∀i:z)(0 ≤ i < |s| ⇒L maximovalor(s[i]) ≤ maximovalor(m))
}
d) proc interseccionMultiple(in ls : seqhseqhRii, out l : seqhRi) que devuelve en l el resultado de la intersecci´on de todas las
secuencias de ls.
e) F Dada una secuencia l con todos sus elementos distintos, devolver la secuencia de partes, es decir, la secuencia de todas las
secuencias incluidas en l, cada una con sus elementos en el mismo orden en que aparecen en l.


Ejercicio 17. F Dados dos enteros a y b, se necesita calcular su suma, y retornarla en un entero c. ¿C´uales de las siguientes
especificaciones son correctas para este problema? Para las que no lo son, indicar por qu´e
a)inout estan mal hecho
b)triple in y ningun out 
c)ta bien 
d)sacamos a y b al pedisimo 

Ejercicio 18. F Dada una secuencia l, se desea sacar su primer elemento y devolverlo. Decidir c´uales de estas especificaciones
son correctas. Para las que no lo son, indicar por qu´e y justificar con ejemplos.
a) No se esta sacando el primer elemento de l, meramente se lo extrae
b) No se esta sacando el primer elemento de l, meramente se lo extrae
c) No se guarda el valor inicial de L, por lo tanto no se sabe que ser´ıa L0
d)correcto 
e)correcto 

Ejercicio 19. Considerar la siguiente especificacion:
proc intercambiar (inout l: seqhRi, in i, j: Z) {
Pre {0 ≤ i < |l| ∧ 0 ≤ j < |l| ∧ l = L0}
Post {
/*Las secuencias tienen la misma longitud*/
|l| = |L0|
∧
/*Intercambia i*/
l[i] = L0[j]
∧
/*Intercambia j*/
l[j] = L0[i]
}
}
a) ¿Esta especificacion es valida? Si lo es, ¿que problema describe?swap
b) Mostrar con un ejemplo que la postcondicion esta sub-especificada (es decir, que hay valores que la hacen verdadera aunque
no son deseables como solucion).#no dice nada de las otras posicion
c) Corregir la especificacion agregando a la postcondicion una o mas clausulas Pos
agrego un (∀j:Z)(0 ≤ h < |l| ∧ h!=i ∧ h!=j ⇒L l[h]=l0[h])

Ejercicio 20. Explicar coloquialmente la siguiente especificaci´on:
proc copiarPrimero (inout l:seqhZi, inout i:Z) {
Pre {
l = L0 ∧ i = I0 ∧ |l| > 0 ∧ 0 ≤ i < |l|
}
Post {
l[I0] = L0[0] ∧ i = L0[I0] ∧ ((∀j : Z)((0 ≤ j < |l| ∧ j != I0) →L l[j] = L0[I0])
}
}
*lo hice mentalmente*
Ejercicio 21. Dada una secuencia de enteros, se requiere multiplicar por 2 aqu´ellos valores que se encuentran en posiciones
pares. Indicar por qu´e son incorrectas las siguientes especificaciones, y proponer una alternativa correcta.
*lo hice mentalmente*
