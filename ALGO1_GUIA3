Ejercicio 1.  Las siguientes especificaciones no son correctas. Indicar por que, y corregirlas para que describan correctamente
el problema.
a) buscar: Dada una secuencia y un elemento de esta, devuelve en result alguna posicion de la secuencia en la cual se encuentre
el elemento.
proc buscar (in l: seq<R>, in elem: R, out result: Z) {
Pre {elem ∈ l}
Post {0 ≤ result < |l| ∧L	
	l[result] = elem}
}
b) progresionGeometricaFactor2: Indica si la secuencia l representa una progresion geometrica factor 2. Es decir, si cada
elemento de la secuencia es el doble del elemento anterior.
proc progresionGeometricaFactor2 (in l: seqhZi, out result: Bool) {
Pre {T rue}
Post {result = True ↔ ((∀i : Z)(0 ≤ i < |l|-1 →L l[i] = 2 ∗ l[i + 1]))}
}
c) minimo: Devuelve en result el menor elemento de l.
proc minimo (in l: seqhZi, out result: Z) {
Pre {True}
Post {(∀i : Z)(0 ≤i <|l|) →L (∃ result)(0 ≤ result <|l| l[i] => result))}
}

Ejercicio 2. La siguiente no es una especificacion valida, ya que para ciertos valores de entrada que cumplen la precondicion,
no existe una salida que cumpla con la postcondicion.
proc elementosQueSumen (in l: seq<Z>, in suma:Z, out result: seq<Z>) {
Pre {True}
Post {
/* La secuencia result esta incluıda en la secuencia l*/
(∀x : Z)(x ∈ result → #apariciones(x, result) ≤ #apariciones(x, l))
/* La suma de la result coincide con el valor suma */
∧ suma=sum(|result|−1,0,i) result[i]}
}
a) Mostrar valores para l y suma que hagan verdadera la precondicion, pero tales que no exista result que cumpla la postcondicion.

l=[1,2,3]
suma=3
result[1,2]

l=[]
suma=1
suma de result = 0 

b) Supongamos que agregamos a la especificacion la siguiente clausula:
Pre : min suma(l) ≤ suma ≤ max suma(l)
fun min suma(l) : Z =
|l|−1
i=0 if l[i] < 0 then l[i] else 0 fi
fun max suma(l) : Z =
|l|−1
i=0 if l[i] > 0 then l[i] else 0 fi
¿Ahora es una especificacion valida? Si no lo es, justificarlo con un ejemplo como en el punto anterior 

se rompen con 
l=[1,3]
suma=2

c) Dar una precondici´on que haga correcta la especificaci´on.
|l| ≥ 1 ∧l suma ≤ maximo(l)



Ejercicio 3. Para los siguientes problemas, dar todas las soluciones posibles a las entradas dadas.
a) proc raizCuadrada (in x:R, out result:R) {
Pre {x ≥ 0}
Post {result^2  = x}
}
i) x = 0 ⇒ 0
ii) x = 1 ⇒ 1 and -1
iii) x = 27 ⇒ sqrt(27) , -sqrt(27)


proc indiceDelMaximo (in l: seqhRi, out result:Z) {
Pre {|l| > 0}
Post {
0 ≤ result < |l|
∧L ((∀i : Z)(0 ≤ i < |l| →L l[i] ≤ l[result])}
}

i) l = h1, 2, 3, 4i   ⇒  3
ii) l = h15.5, −18, 4.215, 15.5, −1i ⇒ 0 ,3
iii) l = h0, 0, 0, 0, 0, 0i ⇒ 0,1..5 

c) 
proc indiceDelPrimerMaximo (l:seqhRi, result:Z) {
Pre {|l| > 0}
Post {
0 ≤ result < |l|
∧ ((∀i : Z)(0 ≤ i < |l| →L (l[i] < l[result] ∨ (l[i] = l[result] ∧ i ≥ result))))}
}
i) l = h1, 2, 3, 4i ⇒ 3
ii) l = h15.5, −18, 4.215, 15.5, −1i ⇒0
iii) l = h0, 0, 0, 0, 0, 0i ⇒0


Ejercicio 4. F Sea f : R × R → R definida como:
				
					| 2b si a < 0
f(a, b) = | b − 1 en otro caso

¿Cuales de las siguientes especificaciones son correctas para el problema de calcular f(x, y)?
Para las que no lo son, indicar por que

a) proc f (in a, b:R ,out result:R) {
Pre {True}
Post {
(a < 0 ∧ result = 2 ∗ b)
∧
(a ≥ 0 ∧ result = b − 1)
}
}
sera falso ,debe haber un ∨ no un ∧

b) proc f (in a, b: R, out result:R) {
Pre {True}
Post {(a < 0 ∧ result = 2 ∗ b) ∨ (a > 0 ∧ result = b − 1)}
}
incorrecto

c) proc f (in a, b: R, out result:R) {
Pre {T rue}
Post {(a < 0 ∧ result = 2 ∗ b) ∨ (a ≥ 0 ∧ result = b − 1)}
}
correcto 

d) proc f (in a, b: R, out result:R) {
Pre {T rue}
Post {
a < 0 → result = 2 ∗ b
∧
a ≥ 0 → result = b − 1
}
}
incorrecto

e) proc f (in a, b: R, out result:R) {
Pre {T rue}
Post {(a < 0 → result = 2 ∗ b) ∨ (a ≥ 0 → result = b − 1)}
}
incorrecto

f) proc f (in a, b: R, out result: R) {
Pre {T rue}
Post {result = (if a < 0 then 2 ∗ b else b − 1 fi)}
}
correcto 


Ejercicio 5. Considerar la siguiente especificacion, junto con un algoritmo que dado x devuelve x^2

proc unoMasGrande (in x: R, out result:R) {
Pre {T rue}
Post {result > x}
}
a) ¿Que devuelve el algoritmo si recibe x = 3? ¿El resultado hace verdadera la postcondicion de unoMasGrande?
devuelve 9 y hace verdadera
b) ¿Que sucede para las entradas x = 0.5, x = 1, x = −0.2 y x = −7?
da 0.25 pero no cumple postcondicion, 1 da 1 no cumple posticoindcion ,da 49 y cumple postcondicon
c) Teniendo en cuenta lo respondido en los puntos anteriores, escribir una precondicion para unoMasGrande, de manera tal que
el algoritmo sea una implementacion correcta.
pre{x>1 ∨ x≤-1 }


Ejercicio 6.  Sean x y r variables de tipo R. Considerar los siguientes predicados:

P1: {x ≤ 0} 		Q1: {r ≥ x^2}
P2: {x ≤ 10} 		Q2: {r ≥ 0}
P3: {x ≤ −10}   Q3: {r = x^2}

a) Indicar la relaci´on de fuerza entre P1, P2 y P3.
P3 > P1 > P2
b) Indicar la relaci´on de fuerza enrte Q1, Q2 y Q3.
Q3 > Q1 > Q2

c) Sea E1 la siguiente especificaci´on. Escribir 2 programas que cumplan con E1.
proc hagoAlgo (in x: R, out r:R) {
Pre {x ≤ 0}
Post {r ≥ x^2}
}

f(x:R){
	result = x * x 
	return result 
}
r : = (x − 1)^2 , r := x^2

d) Sea A un algoritmo que cumple con E1. Decidir si necesariamente cumple las siguientes especificaciones:
a) Pre: {x ≤ −10}, Post: {r ≥ x^2}si
b) Pre: {x ≤ 10}, Post: {r ≥ x^2}no
c) Pre: {x ≤ 0}, Post: {r ≥ 0}si
d) Pre: {x ≤ 0}, Post: {r = x^2}no
e) Pre: {x ≤ −10}, Post: {r ≥ 0}si
f ) Pre: {x ≤ 10}, Post: {r ≥ 0}no
g) Pre: {x ≤ −10}, Post: {r = x^2}no
h) Pre: {x ≤ 10}, Post: {r = x^2}no


Ejercicio 7.  Considerar las siguientes dos especificaciones, junto con un algoritmo a que satisface la especificacion de p2.

proc p1 (in x: R, in n: Z, out result:Z) {
Pre {x ≠ 0}
Post {x^(n)− 1 < result ≤ x^n}
}
proc p2 (in x: R, in n: Z, out result:Z) {
Pre {n ≤ 0 → x ≠ 0}
Post {result = parteEntera(x^n)}
}

a) Dados valores de x y n que hacen verdadera la precondicion de p1, demostrar que hacen tambien verdadera la precondicion
de p2.
si x ≠ 0 entonces en el pre de p2 el n tiene que se menor a 0 y no hay restricion asi que esta bien 
b) Ahora, dados estos valores de x y n, supongamos que se ejecuta a: llegamos a un valor de res que hace verdadera la
postcondicion de p2. ¿Sera tambien verdadera la postcondicion de p1?
cumple
c) ¿Podemos concluir que a satisface la especificacion de p1?
si x=2 y n=-1 
1/2 result 1/2 falso 

Ejercicio 8. Considerar las siguientes especificaciones:
proc n-esimo1 (in l: seqhZi, in n: Z, out result: Z) {
Pre {
/*Los elementos estan ordenados*/
(∀i : Z)(0 ≤ i < |l| − 1 →L l[i] < l[i + 1]) ∧ 0 ≤ n < |l|}
Post {result = l[n]}
}


proc n-esimo2 (in l: seqhZi, in n: Z, out result:Z) {
Pre {
/*Los elementos son distintos entre sı*/
(∀i : Z)(0 ≤ i < |l| →L ((∀j : Z)(0 ≤ j < |l| ∧ i != j) →L l[i] != l[j]))
∧
0 ≤ n < |l|}
Post {
result ∈ l
∧
n =sum(l,0,|l|-1,i)(if l[i] < result then 1 else 0 fi)}
}
¿Es cierto que todo algoritmo que cumple con n-esimo1 cumple tambi´en con n-esimo2? ¿Y al rev´es?
Si un algoritmo cumple la pre de p1, entonces cumple la de p2. Ya que una lista ordenada
tiene todos elementos distintos, y ambos aseguran que 0 ≤ n < |l|. Pero si cumple la pre de
p2 no necesariamente cumple la de p1 (ej.: h1, 3, 2i).
Y la post de p1 tambi´en cumple p2. Porque la sumatoria de p2 est´a preguntando cu´antos
n´umeros menores a result hay, que es lo mismo que la posici´on de la secuencia ordenada

Ejercicio 9. F Especificar los siguientes problemas:
a) Dado un numero entero, decidir si es par.
proc esPar (in n: Z, out res: Bool) {
Pre {T rue}
Post {eje_a(n)}
}
pred eje_a(x:Z){
	x mod 2 == 0
}
b) Dado un entero n y uno m, decidir si n es un multiplo de m.
proc esMultiplo (in n, m: Z, out res: Bool) {
Pre {T rue}
Post {eje_b(n,m)}
}
pred eje_b(n,m:Z){
	n mod m == 0
}
c) Dado un numero real, devolver su inverso multiplicativo.
c) proc inverso (in x: R, out res: R) {
Pre {x != 0}
Post {res = inv_mul(x) }
}
aux inv_mul(x:R):R = (if x==0 then 0 else 1/x)
d) Dada una secuencia de caracteres, obtener de ella solo los que son numericos (con todas sus apariciones sin importar el orden
de aparicion).
d) proc obtenerNumericos ( in l : seqhChari, out lis : seqhChari) {
Pre {T rue}
Post {(∀c : Char) ( (ord(‘0‘) ≤ ord(c) ≤ ord(‘9‘) → apariciones(c, l) ==
apariciones(c, lis)) ∧ (c ∈ lis → ord(‘0‘) ≤ ord(c) ≤ ord(‘9‘) ))}
}
e) Dada una secuencia de reales, devolver la secuencia que resulta de duplicar sus valores en las posiciones impares
proc dupl_imp(in s: seq<R> ,out res:seq<R>){
	pre{True}
	post{ |s|=|res| ∧L
	(∀i:z)(0 ≤ i < |s| ⇒L  
		if i mod 2 == 0 then s[i]=res[i] else res[i]=s[i]*2
		}
}
f) Dado un numero entero, listar todos sus divisores positivos (sin duplicados).
proc divisoresPositivos (in n: Z, out res: seqhZi) {
Pre {T rue}
Post {sinRepetidos(res) ∧ (∀i : Z)((i > 0 ∧L n m´od i == 0) ↔ i ∈ res)}
}
